# My Learning Note

 ```
 資料結構與演算法
 巨資三B 金元萱
 ```

## Week 1

中秋節放假  

## Week 2 

**Linked List & Array**

   ![](https://miro.medium.com/max/1732/1*aeJZmbE3xBDZfYOu6p5CPw.png)

- Linked List：由節點（node）組成資料，再由pointer指向下一個節點，藉此串連起來，以null表達終點，可以不連續的資料型態儲存在記憶體中。
   * 優點：可利用記憶體中零散空間，需要多少就使用多少
   * 缺點：無法隨機存取、查詢，需走訪各節點

- Array：以連續的資料型態儲存在記憶體中。
   * 優點：使用容易
   * 缺點：刪除與插入資料較為麻煩、浪費不必要的記憶體空間
   
## Week 3

**Stack & Queue**

![](https://www.thecrazyprogrammer.com/wp-content/uploads/2016/05/Difference-Between-Stack-and-Queue.jpg)

- Stack：資料以堆疊的方式呈現（疊盤子），先進後出，例子：undo，回上一頁。
   * Push：放資料進Stack
   * Pop：將最上面資料移除
   * Top：讀取最上面資料
   * IsEmpty：確認Stack裡是否有資料
   * getSize：回傳羅馬資料個數

- Queue：資料以排列方式呈現（排隊），先進先出，例子：CPU、印表機，一次照順序執行一個需求。
   * Push：放資料進Queue
   * Pop：將最前面資料移除，又稱Dequeue
   * getFront：讀取第一筆資料
   * getBack：讀取最後一筆資料
   * IsEmpty：確認Queue裡是否有資料
   * getSize：回傳資料個數

## Week 4

**Set Mismatch**

- 題目：一個list為[1,2,3,3,3,5]，排出缺失值與重複值。
- 構想：先設一個holder=[0,0,0,0,0,0]，其位置i分別為0,1,2,3,4,5，將list依序填入holder，holder中list[i＝0]-1為0＝holder[0]=list[0]=1，依序檢驗，重複值為3，缺失值為holder.index(0)+1=4。

**Leetcode | Roman to Integer**

- 題目：指定數字為羅馬符號，依照題目給的符號跑出對應數字。
- 構想：先將羅馬符號指定為對應數字{'M':1000,'D':500,'C':100,'L':50,'X':10,'V':5,'I':1}，設定i位置從0至符號個數-1，以符號第i位小於或大於i+1位做判別。 


**Insertion Sort**

- Insertion Sort：將資料以左至右依序檢視，由第一筆開始插入以排序好之資料，插入時以右至左檢視資料。
> `6` 5 3 1 8 7 2 -> 6 `5` 3 1 8 7 2 -> 5 6 `3` 1 8 7 2 -> 3 5 6 `1` 8 7 2 以此類推 
- bubble sort：將資料由左至右兩兩相互比較、交換位子，最後一位則為已排序好之資料，再從頭開始至全部資料排序結束。
> `6` `5` 3 1 8 7 2 -> 5 `6` `3` 1 8 7 2 -> 5 3 `6` `1` 8 7 2 以此類推
- quick sort：在資料中找基準點，以基準點將資料分為兩堆，在兩堆中繼續找基準點分為四堆，直至排序完成。
   * n*1/2**x＝1 -> log2n=x.
> 6 5 `3` 1 8 7 2 -> 1 2 `3` 6 5 8 7 -> `1` 2 3 6 5 8 `7` -> 1 2 3 6 5 `7` 8 以此類推

## Week 5

國慶日放假


## Week 6

**Heep Sort**

![](https://1.bp.blogspot.com/-5WRKOWTm3NM/W--3ORaY2LI/AAAAAAAEHLw/wbZf81L8bBYZHZR6stpCTbfptMTkMaAKgCLcBGAs/s1600/2018_11_17_heap.png)

堆積排序法：將一個數列排成完全二元樹，每一個父節點必須大於兩個子節點，形成 Max Heap，將第一個節點與最後一個節點交換，此時最後一個節點為最大的數並以排列完成，忽略最後一個節點重複前面步驟，直至數列排列完成。

   ```
   Min Heap：頂層節點數值必定大於下層的二元樹
   Max Heap：頂層節點數值必定小於下層的二元樹
   Heapify：將一個數列排成完全二元樹
   ```
## Week 7

**Merge Sort** 

![](https://kopu.chat/wp-content/uploads/2017/08/merge.gif)

合併排序法：將一個數列不斷對半分成兩個小數列，直至每一個小數列剩下一個元素為止，再將小數列倆倆排序後合併至最後的排序完成數列。

- 6 2 9 5 對半分，6 2、9 5 再對半分。
- 6、2 排序後合併，9、5 排序後合併。
- 2 6、5 9 排序後合併。

## Week 8

**Binary Tree**

![](https://pic.pimg.tw/emn178/1354416914-2701915548_n.png)

二元樹：將數列排成每個節點最多只有兩個分支的樹結構。通常分支被稱作「左子樹」或「右子樹」，具有左右次序，不能隨意顛倒。

## Week 9

**Binary Search Tree** 

![](https://cdn.softwaretestinghelp.com/wp-content/qa/uploads/2019/08/1-sample-BST.png)

二元搜尋樹：將數列排成完全二元樹，一個父節點最多有兩個子節點，父節點大於左子節點、小於右子節點，每一個節點會指向下一個節點，最後一個節點會指向 None，以這個條件去執行新增、查詢、刪除，以及修改節點的功能。

- insert：若要新增一個值至 BST ，會由上往下循著去與每一個父節點與子節點比較大小，最終此值會放在 BST 的最尾端（不會有子節點），而並非在中途插入新增。
- search：若要查詢 BST 中的一個值，首先必須先確定此值有無在 BST 中，有的話可由上往下循著去與每一個父節點與子節點比較大小去找到此值。
- delete：若要刪除 BST 中的一個值，首先必須先確定此值有無在 BST 中，有的話可由上往下循著去與每一個父節點與子節點比較大小去找到此值，要將此值刪除，須先注意此值有無子節點，若沒有孩子，須將此值的父節點指向 None，若有孩子，須將此值的父節點指向此值的孩子，並將 BST 中的第一個父節點替換成此值的右子節點中的最小值，要注意的是，有重複之值必須重複刪除。
- modify：若要將 BST 中的一個值修改成另一個值，先進行刪除的動作，接下來再新增，刪除了幾個重複的值，就必須新增幾個新的值。

## Week 10

**Red Black Tree** 

 ![](https://yotsuba1022.gitbooks.io/data-structure-note/assets/rbtree-2.png)

紅黑樹：為增加了某些特性的二元搜尋樹，在每個節點增加一個屬性表示節點顏色，值為紅色或者黑色。它可以保持樹的大致平衡，在插入或刪除節點的時候,，檢查是否破壞了樹的特性，若破壞了則進行糾正，進而保持樹的平衡。

- 每個節點不是紅就是黑的。
- 根是黑色的。
- 若節點是紅色的，則其子節點必為黑色，反之不必為真。
- 每個空子節點都是黑色的。
- 從根節點到葉節點或空子節點的每條路徑，必須包含相同數目的黑色節點。
